<!DOCTYPE html>
<html>
  <head>
    <title>自動樂譜</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body {
        margin: 0;
        height: 100vh;
        padding: 8px;
        box-sizing: border-box;
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 8px;
      }
      #樂譜 {
        display: grid;
        align-content: start;
        gap: 8px;
        height: 100%;
        overflow: auto;
        scroll-behavior: smooth;
      }
      #樂譜::-webkit-scrollbar { display: none; }
      .小節 {
        display: grid;
        grid-template-rows: repeat(var(--r), var(--sq_h));
        grid-template-columns: repeat(var(--c), 1fr);
        height: max-content;
        gap: var(--gap);
        --sq_hg: calc(var(--sq_h) + var(--gap));
        --sq_wg: calc(var(--sq_w) + var(--gap));
        --cell_w: calc(var(--sq_wg) * 4 - var(--gap));
        --cell_wg: calc(var(--cell_w) + var(--gap));
        background: linear-gradient(#8ec98e30) no-repeat left calc(var(--sq_hg) * 5) / 100% var(--sq_h),
                    linear-gradient(90deg, #0000 var(--cell_w), #c3c3c3 var(--cell_w)) left / var(--cell_wg) auto,
                    linear-gradient(#0000 var(--sq_h), #dfdfdf var(--sq_h)) top / auto calc(var(--sq_h) + var(--gap)),
                    linear-gradient(90deg, #0000 var(--sq_w), #dfdfdf var(--sq_w)) left / var(--sq_wg) auto;
        background-color: #eee;
        overflow: hidden;
      }
      .小節:after {
        content: attr(index);
        grid-area: 1 / 1;
        font-size: var(--sq_h);
        font-family: sans-serif;
        text-align: center;
        pointer-events: none;
        position: relative;
        top: -1px;
        font-weight: bold;
        opacity: .5;
      }
      .小節 i {
        border: 1px solid #0003;
        border-radius: 4px;
      }
      i:before {
        display: block;
        text-align: center;
        opacity: .2;
        font-style: normal;
      }
      i.碎音鈸 { grid-row: 1; background: #efac7f; } i.碎音鈸:before { content: "磅"; }
      i.高帽鈸 { grid-row: 2; background: #ebe697; } i.高帽鈸:before { content: "此"; }
      i.高帽鈸.開鈸 { background: #f5f3c9; } i.高帽鈸.開鈸:before { content: "叮"; }
      i.疊音鈸 { grid-row: 3; background: #fca; } i.疊音鈸:before { content: "聽"; }
      i.高音中鼓 { grid-row: 4; background: #abdaf7; } i.高音中鼓:before { content: "湯"; }
      i.低音中鼓 { grid-row: 5; background: #a3c3ff; } i.低音中鼓:before { content: "通"; }
      i.小鼓 { grid-row: 6; background: #8ec98e; } i.小鼓:before { content: "噠"; }
      i.小鼓.鼓框 { background: #d6f7d6; } i.小鼓.鼓框:before { content: "喀"; }
      i.落地鼓 { grid-row: 7; background: #a99bdd; } i.落地鼓:before { content: "碰"; }
      i.大鼓 { grid-row: 8; background: #ef9e9e; } i.大鼓:before { content: "動"; }
      i.腳踏鈸 { grid-row: 9; background: #ebe697; } i.腳踏鈸:before { content: "他"; }
      i.碎音鈸[style="grid-column: 1 / span 1;"]:before { display: none; }
      #樂譜.不要字 i:before { display: none; }
      i[l="4"] { grid-column-end: 16 span; }
      i[l="3"] { grid-column-end: 12 span; }
      i[l="2"] { grid-column-end: 8 span; }
      i[l="1.5"] { grid-column-end: 6 span; }
      i[l="1"] { grid-column-end: 4 span; }
      i[l="0.75"] { grid-column-end: 3 span; }
      i[l="0.5"] { grid-column-end: 2 span; }
      i[l="0.25"] { grid-column-end: 1 span; }
      #mark {
        background: #52c75252;
        grid-column: 1;
        grid-row: 1 / -1;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="控制區">
      <input id="隨機譜開頭要幾小節" value="1" style="width: 60px;"/>開頭小節
      <input id="隨機譜要幾小節" value="8" style="width: 60px;"/>小節
      <button onclick="產生隨機譜()">產生隨機譜</button><br/>
      <input id="隨機譜模式" value="頭 身 身 尾" style="width: 300px;"/><br/>
      <input id="固定譜名" style="width: 120px;"/><button onclick="讀取固定譜()">讀取固定譜</button><br/>
      <input id="儲存譜名" style="width: 120px;"/><button onclick="儲存目前的譜()">儲存目前的譜</button><br/>
      <hr/>
      <button onclick="新增小節()">新增小節</button>
      <button onclick="回退一步()">上一步</button>
      <button onclick="重做一步()">下一步</button><br/>
      <button onclick="播放器.停止()">停止</button>
      <button onclick="播放器.暫停()">暫停</button>
      <button onclick="播放器.播放()">播放</button>
      BPM <input id="BPM" type="number" oninput="播放器.改變BPM()" value="60" style="width: 60px;"/>
      指針 <input id="播放_cur" type="number" oninput="播放器.播針()" step="0.25" value="0" style="width: 60px;"/>
      <button onclick="播放_cur.value = +播放_cur.value - 0.25; 播放器.播針();">←</button>
      <button onclick="播放_cur.value = +播放_cur.value + 0.25; 播放器.播針();">→</button><br/>
      <label><input type="checkbox" onclick="樂譜.classList.toggle('不要字', this.checked)" checked />隱藏唸法</label>
      <label><input id="不要聲音" type="checkbox" checked />不要聲音</label>
    </div>
    <div id="樂譜" class="不要字" onclick="點整個譜()">
      <div class="小節" index="1"><mark id="mark"></mark></div>
    </div>
    <script>
      const 聲編號 = {
        大鼓: "BD", 小鼓: "SD", 小鼓_鼓框: "SS",
        高音中鼓: "HT", 低音中鼓: "LT", 落地鼓: "FT",
        碎音鈸: "CC", 疊音鈸: "RC",
        高帽鈸: "HH", 高帽鈸_開鈸: "HO", 腳踏鈸: "HF",
      };
      function 編號轉名(編號) { return Object.entries(聲編號).find(([key, val]) => val == 編號)[0]; }
      let 譜 = [];

      /* ================================ */
      /*  操作                            */
      /* ================================ */
      function 點小節(event) {
        let gap = parseFloat(getComputedStyle(event.target).getPropertyValue("--gap"));
        let sq_w = parseFloat(getComputedStyle(event.target).getPropertyValue("--sq_w"));
        let sq_h = parseFloat(getComputedStyle(event.target).getPropertyValue("--sq_h"));
        let r = Math.floor(event.offsetY / (sq_h + gap));
        let c = Math.floor(event.offsetX / (sq_w + gap));
        let 音 = ["碎音鈸", "高帽鈸", "疊音鈸", "高音中鼓", "低音中鼓", "小鼓", "落地鼓", "大鼓", "腳踏鈸"][r];
        let 第幾小節 = [...樂譜.children].indexOf(event.target);
        let 時 = 第幾小節 * 顯示設定.c / 4 + c / 4;
        let data = {音, 時, 長: 0.25};
        if(找重疊(data)) return;
        新音(data);
        紀錄新步驟();
      }
      function 新音(data) {
        譜.push(data);
        let 小節 = Math.floor(data.時 / (顯示設定.c / 4));
        let i = document.createElement("i");
        i.data = data;
        i.classList.add(data.音);
        if(data.鼓框) i.classList.add("鼓框");
        if(data.開鈸) i.classList.add("開鈸");
        更新i(i);
        樂譜.children[小節].append(i);
      }
      function 找重疊(data) {
        return !!譜
          .filter(dot => dot != data)
          .filter(dot => dot.音 == data.音)
          .find(dot => dot.時 < data.時 + data.長 && dot.時 + dot.長 > data.時);
      }
      function 點音符(target) {
        let data = target.data;
        data.長 += 0.25;
        let 超過最長拍 = data.長 > 1.5;
        let 超過小節寬 = (data.時 % (顯示設定.c / 4) + data.長) > 顯示設定.c / 4;
        if(超過最長拍 || 超過小節寬 || 找重疊(data)) data.長 = 0.25;
        更新i(target);
        紀錄新步驟();
      }
      function 雙點音符(target) {
        if(target.data.音 == "高帽鈸" && !target.data.開鈸) {
          target.data.開鈸 = true;
          target.classList.add("開鈸");
        }
        else if(target.data.音 == "小鼓" && !target.data.鼓框) {
          target.data.鼓框 = true;
          target.classList.add("鼓框");
        }
        else {
          let index = 譜.indexOf(target.data);
          譜.splice(index, 1);
          target.remove();
        }
        紀錄新步驟();
      }
      function 更新i(i) {
        let c = i.data.時 % (顯示設定.c / 4) * 4 + 1;
        i.style.gridColumn = `${c} / ${i.data.長 * 4} span`;
      }
      function 新增小節() {
        let 新小節 = document.createElement("div");
        新小節.classList.add("小節");
        樂譜.append(新小節);
        新小節.setAttribute("index", document.querySelectorAll(".小節").length);
      }

      /* ================================ */
      /*  紀錄                            */
      /* ================================ */
      let 步驟紀錄 = [""];
      let 目前步 = -1;
      function 紀錄新步驟() {
        if(目前步 != -1) 步驟紀錄 = 步驟紀錄.slice(0, 目前步 + 1);
        步驟紀錄.push(取得譜());
        if(步驟紀錄.length > 30) 步驟紀錄 = 步驟紀錄.slice(-30);
        目前步++;
      }
      function 回退一步() {
        if(目前步 <= 0) return;
        目前步--;
        清除全部();
        譜字串加入(步驟紀錄[目前步]);
      }
      function 重做一步() {
        if(目前步 >= 步驟紀錄.length - 1) return;
        目前步++;
        清除全部();
        譜字串加入(步驟紀錄[目前步]);
      }

      /* ================================ */
      /*  節處理                          */
      /* ================================ */
      function 清除全部() {
        樂譜.querySelectorAll(".小節:not(:first-child), i").forEach(el => el.remove());
        譜 = [];
      }
      function 譜資料輸入(資料) {
        清除全部();
        for(let key in 資料.元素) {
          if(/\&|\(/.test(資料.元素[key])) 資料.元素[key] = 元素轉譜(資料.元素[key]);
        }
        資料.譜.forEach(句子 => {
          句子.split(" ").forEach(指定元素 => {
            let 元素名 = 指定元素.replace(/^.*\]/g, "");
            let 起頭位置 = 指定元素.replace(/[^\]]*$/, "");
            譜字串加入(起頭位置 + 資料.元素[元素名]);
          });
        });
      }
      function 元素轉譜(元素字串) {
        let 譜字串 = [];
        元素字串.split("&").forEach(音字串 => {
          let 時 = 0;
          let 音 = 音字串.replace(/\(.*$/, "");
          音字串.replace(/^.*\(|\)$/g, "").match(/[Xx'Oo.Qq,][\*\~]*/g).forEach(字 => {
            let 長 = 0;
            switch(字[0]) {
              case "X": case "O": case "Q": 長 = 1; break;
              case "x": case "o": case "q": 長 = 0.5; break;
              case "'": case ".": case ",": 長 = 0.25; break;
            }
            長 *= 2 ** (字.split(/\*/).length - 1);
            if(/\~/.test(字)) 長 *= 1.5;
            if(!/[Xx']/.test(字)) {
              let 特 = /[Qq\,]/.test(字) ? "!" : "";
              譜字串.push(`${音}${特}-${時}-${長}`);
            }
            時 += 長;
          });
        });
        return 譜字串.join(" ");
      }

      /* ================================ */
      /*  譜處理                          */
      /* ================================ */
      async function 儲存目前的譜() {
        let btn = document.querySelector('[onclick="儲存目前的譜()"]');
        btn.disabled = true;
        let sents = {};
        let sheet = [];
        let 譜長 = Math.ceil(document.querySelectorAll(".小節").length / 4);
        for(let f = 0; f < 譜長; f++) {
          let 拍起頭 = f * 16;
          let 小節起頭 = f * 4;
          let sent_name = "sent" + 小節起頭;
          sents[sent_name] = 取得譜(拍起頭, 16);
          if(小節起頭 % 16 == 0) sheet.push(`[${小節起頭}]${sent_name}`);
          else sheet[Math.floor(小節起頭 / 16)] += ` [${小節起頭}]${sent_name}`;
        }
        let res = await post("儲存譜", {name: 儲存譜名.value, sents, sheet});
        alert(res.data.error || res.data.success);
        btn.disabled = false;
      }
      async function 讀取固定譜() {
        播放器.停止();
        let btn = document.querySelector('[onclick="讀取固定譜()"]');
        btn.disabled = true;
        let res = await post("取得固定譜", {name: 固定譜名.value});
        if(res.data) {
          清除全部();
          譜資料輸入(res.data);
        }
        btn.disabled = false;
      }
      async function 產生隨機譜() {
        播放器.停止();
        let btn = document.querySelector('[onclick="產生隨機譜()"]');
        btn.disabled = true;
        let res = await post("取得隨機譜雛形", {});
        let 隨機譜 = res.data;
        let keys = Object.keys(隨機譜.元素);
        隨機譜.元素.起頭四拍 = "HH(oxoxoxox)";
        隨機譜.譜 = [];
        for(let i=0; i<+隨機譜開頭要幾小節.value; i++) 隨機譜.譜.push(`[${i}]起頭四拍`);

        let 類型s = 隨機譜模式.value.split(" ");
        for(let i=0; i<+隨機譜要幾小節.value; i++) {
          let 類型 = 類型s[i % 類型s.length];
          let 此類元素 = keys.filter(key => key.replace(/\_.*$/, '') == 類型);
          let 指定元素 = "起頭四拍";
          if(此類元素.length) 指定元素 = 此類元素[Math.floor(Math.random() * 此類元素.length)];
          else 指定元素 = keys[Math.floor(Math.random() * keys.length)];
          隨機譜.譜.push(`[${i + +隨機譜開頭要幾小節.value}]${指定元素}`);
        }
        清除全部();
        譜資料輸入(隨機譜);
        btn.disabled = false;
      }

      /* ================================ */
      /*  譜處理                          */
      /* ================================ */
      function 取得譜(start, length) {
        if(!start) start = 0;
        start -= start % (顯示設定.c / 4);
        if(!length) length = Math.max(...譜.map(({時, 長}) => 時 + 長));
        return 譜
          .filter(dot => dot.時 >= start && dot.時 < start + length)
          .map(({音, 時, 長, 開鈸, 鼓框}) => {
            let 編號 = 聲編號[音];
            let 特音 = (開鈸 || 鼓框) ? "!" : "";
            return `${編號}${特音}-${時 - start}-${長}`;
          }).join(" ");
      }
      function 譜字串加入(譜完整字串) {
        let 起 = 譜完整字串[0] == "[" ? +譜完整字串.replace(/^\[|\].*$/g, "") * 4 : 0;
        let 譜字串 = 譜完整字串.replace(/^.*\]/g, "");
        let 新譜 = !譜字串 ? [] : 譜字串.split(" ").map(字串 => {
          let [編號, 時, 長] = 字串.split("-");
          let data = {
            音: 編號轉名(編號.replace(/\!/g, "")),
            時: +時 + 起,
            長: +長,
          };
          if(/\!/.test(編號)) {
            if(data.音 == "小鼓") data.鼓框 = true;
            if(data.音 == "高帽鈸") data.開鈸 = true;
          }
          return data;
        });
        let 結尾 = Math.max(...新譜.map(({時, 長}) => 時 + 長));
        let 幾小節 = Math.ceil(結尾 / (顯示設定.c / 4));
        播放器.停止();
        while(樂譜.childElementCount < 幾小節) 新增小節();
        新譜.forEach(data => 新音(data));
      }

      /* ================================ */
      /*  播放                            */
      /* ================================ */
      const 播放器 = (() => {
        const obj = {};
        let 播放狀態 = false;
        let 開始時間 = 0;
        let 間隔 = 0;

        /* 控制區 */
        obj.播放 = function() {
          開始時間 = new Date().getTime();
          播放狀態 = true;
        }
        obj.暫停 = function() {
          播放狀態 = false;
        }
        obj.停止 = function() {
          播放狀態 = false;
          樂譜.children[0].append(mark);
          mark.style.gridColumn = 1;
          播放_cur.value = 0;
          樂譜.scrollTop = 0;
        }

        /* 設定區 */
        Object.defineProperty(obj, "改變BPM", { value: 改變BPM, writable: false });
        function 改變BPM() {
          間隔 = 60e3 / +BPM.value / 4;
        }
        改變BPM();

        /* 每針 */
        Object.defineProperty(obj, "max", {
          get: () => {
            let max = 樂譜.childElementCount * 顯示設定.c / 4 - 0.25;
          },
        });
        Object.defineProperty(obj, "播針", { value: 播針, writable: false });
        function 播針() {
          播放_cur.value = Math.floor(播放_cur.value * 4 / 1) / 4;
          播放_cur.value = Math.min(Math.max(播放_cur.value, 0), 播放器.max);
          播針_顯示();
          播針_聲音();
        }
        function 播針_顯示() {
          let 小節i = Math.floor(播放_cur.value / (顯示設定.c / 4));
          let 小節 = 樂譜.children[小節i] || 樂譜.children[0];
          小節.append(mark);
          樂譜.scrollTop = 小節.offsetTop - 樂譜.offsetTop;
          let c = 播放_cur.value % (顯示設定.c / 4) * 4 + 1;
          mark.style.gridColumn = c;
        }
        function 播針_聲音() {
          if(不要聲音.checked) return;
          譜.filter(({時}) => 時 == +播放_cur.value)
          .map(data => {
            if(data.鼓框) return "小鼓_鼓框";
            if(data.開鈸) return "高帽鈸_開鈸";
            return data.音;
          })
          .forEach(音 => 播一個音(音));
        }

        /* 循環區 */
        function 這一直循環() {
          if(播放狀態) {
            if(new Date().getTime() - 開始時間 >= 間隔) {
              開始時間 = new Date().getTime();
              播放器.播針();
              播放_cur.value = +播放_cur.value + 0.25;
              if(播放_cur.value > 播放器.max) 播放_cur.value = 0;
            }
          }
          requestAnimationFrame(這一直循環);
        }
        requestAnimationFrame(這一直循環);

        return obj;
      })();

      /* ================================ */
      /*  聲音處理                        */
      /* ================================ */
      const 鼓聲名稱 = {
        大鼓: "bass", 小鼓: "share-drum", 小鼓_鼓框: "share-stick",
        // BD bass drum; SD; SS
        高音中鼓: "tom1", 低音中鼓: "tom2", 落地鼓: "floor-tom",
        // T1 high tom; T2 low tom; FT
        碎音鈸: "crash", 疊音鈸: "ride",
        // CC crash cymbal; RC ride cymbal
        高帽鈸: "hihat", 高帽鈸_開鈸: "hihat-open", 腳踏鈸: "hihat-foot",
        // HH; HO; HF
      };
      const 鼓聲 = {};
      function 聲音初始化() {
        Object.entries(鼓聲名稱).forEach(([名稱, 檔名]) => {
          鼓聲[名稱] = {i: 0, arr: []};
          for(let i = 0; i < 8; i++) {
            let audio = new Audio();
            audio.src = `./${檔名}.mp3`;
            鼓聲[名稱].arr.push(audio);
          }
        });
      }
      function 播一個音(名稱) {
        let 音obj = 鼓聲[名稱];
        音obj.arr[音obj.i].play();
        音obj.i = (音obj.i + 1) % 8;
      }
      聲音初始化();

      /* ================================ */
      /*  點擊處理                        */
      /* ================================ */
      let click_event = null;
      let click_count = 0;
      let click_timeout = null;
      function 點整個譜() {
        clearTimeout(click_timeout);
        if(click_event) click_count++;
        else {
          click_event = event;
          click_count = 1;
        }
        click_timeout = setTimeout(() => {
          if(click_event.target.matches(".小節")) 點小節(click_event);
          else if(click_event.target.matches(".小節 i")) {
            if(click_count == 1) 點音符(click_event.target);
            else 雙點音符(click_event.target);
          }
          click_event = null;
          click_count = 0;
        }, 200);
      }

      /* ================================ */
      /*  尺寸處理                        */
      /* ================================ */
      window.addEventListener("load", 尺寸處理);
      window.addEventListener("resize", 尺寸處理);
      const 顯示設定 = {
        r: 9, c: 16, gap: 1,
      };
      function 尺寸處理() {
        let w = 樂譜.offsetWidth;
        let h = 樂譜.offsetWidth / 3;
        let sq_w = (w - 顯示設定.gap * (顯示設定.c - 1)) / 顯示設定.c;
        let sq_h = (h - 顯示設定.gap * (顯示設定.r - 1)) / 顯示設定.r;
        樂譜.style.setProperty("--gap", 顯示設定.gap + "px");
        樂譜.style.setProperty("--r", 顯示設定.r);
        樂譜.style.setProperty("--c", 顯示設定.c);
        樂譜.style.setProperty("--sq_w", sq_w + "px");
        樂譜.style.setProperty("--sq_h", sq_h + "px");
      }

      function post(action, data) {
        if(!window.XMLHttpRequest) {
          alert('無法連線，請更換瀏覽器');
          return;
        }
        data.action = action || "";
        let url = "https://script.google.com/macros/s/AKfycbx0G3vdSY_HaUlTqS1b3sjlrYjhyjKKwkJx9Nv9UiH2-c1AEJpOsJbI99TfSIozhUZveg/exec";
        return new Promise((resolve, reject) => {
          let xhr = new XMLHttpRequest();
          xhr.open("POST", url, true);
          xhr.responseType = "json";
          xhr.addEventListener("load", () => {
            if(xhr.status == 200) {
              resolve(xhr.response);
            }
            else {
              reject(xhr.status);
            }
          });
          xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
          let content = JSON.stringify(data);
          xhr.send("content=" + encodeURI(content));
        });
      }
    </script>
  </body>
</html>
